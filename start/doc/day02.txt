# day02

개발 중 중간중간 확인하는 가장 간단한 방법이 콘솔 화면에서 확인 하는 것

-----------------------------------------------------------------------------

자바를 이용해서 뭔가를 만들고 싶다면 
	컴파일러가 필요하고
	연계편집을 위한 도구가 필요하다.
	(이것을 JVM 이라고 부름.)
	이 두 가지를 제공하는 도구를 다운 받아서 사용해야 하는데
	==> JDK가 바로 이 두 가지 도구를 제공한다.
		물론 이 안에는 2가지 기능 말고도 필요한 각종 도구들이 패키지로 묶어서 제공
	System을 보고 싶다면 System에 ctrl 좌클릭 후 attach 버튼 => external file => jdk 1.8 => src.zip 클릭 후 ok 버튼

--------------------------------------------------------------------------------------

자바로 만든 프로그램을 실행하는 원리

	1. 자바 언어의 문법에 맞게 자연어로 프로그램을 만든다.
		이 프로그램은 저장되어야 한다.
		이 때 규칙이
			1) 저장할 파일의 이름은 class 이름과 반드시 대소문자까지 동일해야 한다.
			2) 확장자는 반드시 .java 로 만들어야 한다.
			
			예 )
				class Test {
				...
				}
				
				==> Test.java : 파일 이름	
	
	2. 만들어진 소스 파일은 컴파일 해야 한다.
		그래야 컴퓨터가 이해할 수 있는 기계어가 탄생되기 때문이다. .class은 JVM 이 사용하는 파일.
		JVM이 클래스 파일을 실행할 수 있도록 해주는 작업이 컴파일 작업
		
		컴파일 하는 방법(형식
			
			javac 파일명.java
			
			ex)
				javac Test.java ==> Test.class 라는 바이트 코드가 만들어짐. 이 바이트 코드를 JVM이 사용하는 것
				
				이때 옵션을 붙여질 수 있다.
				
		컴파일 단계를 거치면 확장자가 .class 인 파일이 만들어지는데,
		이 파일은 바이트 코드라고 한다.
				=> Test.class
				
		참고 )
			cmd 창에서는 현재 폴더에 있는 도구만 사용할 수 있는 것이 원칙이다.
			다른 폴더에 있는 도구를 사용하기 위해서는 연결을 시켜줘야 한다.
			(해당 도구의 위치를 시스템이 인식하고 있으면 된다.)
			이 경로를 "Path" 에 등록해주면 된다. 우리가 JAVA_HOME 이라는 변수를 만든 이유가 버전 업 등 옮겨진다면
			변수인 JAVA_HOME 만 바꿔주면 Path는 수정할 필요가 없기 때문이다
			
		3. 만들어진 class 파일은 배포가 된다.
			=> 다른 사람에게 실행하도록 줄 수 있다.
			
			실행하는 방법
				
				java 클래스이름
				
용어 설명)
	
	API
		==> 운영체제와 프로그램 사이에 원활한 작동을 위해서 
			양쪽을 연결해주는 도구
	라이브러리
		==> API 가 사용하는 도구에 필요한 정보를 기억한 프로개름의 일종
		
		
		우리가 JDK 를 설치하면 
		자바로 만든 프로그램과 해당 운영체재 사이를 원활하게 작동시키기 위한
		API 도 같이 설치된다.
		
		물론 이것에 포함된 라이브러리도 같이 설치된다.
		특정 명령을 수행하기 위해서는 어떤 절차를 거쳐야 하는지를 기록한 문서에 해당한다.
		
		ex)
			if(){
			}
			==> 이 명령을 실행하기 위해서는
				절차가 필요하다.
				그것을 기록해 놓은 문서를 라이브러리 라고 표현한다.
				
		결론적으로 
			API 안에는 라이브러리가 반드시 포함되어야 한다.
			
			
함수는 클래스 블럭 아래에 얼마든지 들어갈 수 있다

public class Test01{
		public static void main(String[] args) {
			System.out.println("안녕하세요!");
			Test01.abc(); // Test01 클래스에 있는 abc() 실행하세요)
	}
		public static void abc() {}
		//
		public static void xyz() {}
}
			
-------------------------------------------------------------------------------------------------------					
			
자바에서 소스코드의 실행에는 영향을 미치지 않고
주로 설명을 하는데 사용하는 문장을 주석이라고 표현한다.
따라서 주석은 컴파일되지 않는다.

자바에서 주석을 표현하는 방법
	1. 단일행(한줄 주석)
		
		형식)
			//
				==> 해당행의 이 기호 이후는 모두 주석으로 처리된다.
	
	2. 다중행(여러 줄)
		
		형식
			/*
				내용
			*/
	
	3. 배포문서에 포함되는 주석
	
		형식)
			/**
			
			*/		

---------------------------------------------------------------------------------------

	함수는 함수 자신이 스스로 실행되는 경우는 없다
	함수는 반드시 누군가 호출해야 실행이 된다
	
	함수를 호출하는 형식)
		
		함수 이름([데이터])	
		
	클래스가 실행되기 위해서는 JVM 에 의해서 실행되는 함수가 있어야 한다.
	
	문제는 JVM 은 아무 함수나 사용하는 것이 아니고
	오직 
		"public static void main(String[] args)"
	이 함수만 호출을 하게 된다.			
			
		==> 이처럼 어떤 프로그램이 시작하는 함수를 진입점 함수라고 이야기 한다.
		보통 맨 처음에 만드는 클래스에서만 딱 한번만 함수를 쓰고 나머지 클래스에는 함수를 가지지 않는다 
					
---------------------------------------------------------------------------------------

클래스 안에는 필요한 함수나 필요한 변수를 포함할 수 있다.
클래스 안에 일반 명령은 절대로 올 수 없다.

이때 클래스에 포함되는 함수, 변수를 멤버라고 부른다.
이때 멤버로 만들어진 변수를 Field 라고 부른다.

멤버 중 속성이 static 인 멤버는 static 멤버라고 부른다.

static 멤버의 특징은
	
	1. static 영역에 실행되는 순간 미리 올려지는 멤버들이다.
	2. 해당 멤버가 소속된 클래스를 new 시켜서 메모리에 올려놓지 않아도
		그 멤버는 사용할 수 있다.
	3. static 영역에 올려지는 멤버는 같은 이름으로 여러개 올려질 수 없다.
		==> 변수의 경우 하나를 공유해서 사용하게 되는 결과가 생긴다.
		
	4. static 함수에서는 static 멤버만(메모리에 등록되어 있는 멤버만...)  사용할 수 있다.

	결론적으로
	
		public class Test {
			int num
			float area;			 // 이처럼 변수도 포함할 수 있다.
			
			public void xyz(){
			}
			
			public void abc(){
			}					// 이처럼 함수도 포함할 수 있다.
			
			public static void main(String[] args{
				실행내용
			}
		}
					
==========================================================================================

리터럴 풀: 데이터 자체가 쌓이는 공간


*** 상수와 변수

	1. 상수
		==> 개발자가 프로그램에게 알려주는 (정보) or (데이터)
		
		ex)
		
			System.out.println("Hello");  // 데이터 자체는 변하지 않는다.
			의 경우 "Hello" 는 상수(Literal)이다. (변경 x)
			
		문제는 상수는 "Literal Pool" 이라는 장소에 일단 올려지게 저장한 후 사용되도록 되어있다.
		
			ex)
				System.out.println("Hello"); 라고 명령을 하면 
					1) 먼저 리터럴 풀에 "Hello" 라는 데이터 자체를 기억시켜 놓고
						==> 이때 리터럴 풀은 메모리 영역이고
							기억되는 데이터는 주소를 가지게 된다.
		
					2) 리터럴 풀에 기억된 데이터를 꺼내서 출력하게 된다.
					
		이때 사용할 수 있는 데이터 종류)
			
			1) 정수형
				일반적인 소수점이 없는 숫자
					ex) 10 		- 10 진수 
						010		- 8  진수
						0x10	- 16 진수
						
			2) 실수형
				소수점이 존재하는 숫자
					ex)
						3.14	- 일반적인 소수 방식
						3.0e5	- 지수 방식
									3.0 * 10의 5제곱
				
			3) 논리형
				참과 거짓을 의미하는 데이터
					ex)
						true
						false
						==> 위의 2가지 이외에는 절대로 논리형을 표현할 수 없다. (자바에서)
					
							boolean bool = true
						
			4) 문자형 - ' '
				오직 한 글자로만 구성된 문자를 의미
				==> 내부적으로는 입력한 문자를 uni code 방식으로 변환해서 기억하게 된다.
				
				'a' = 97 이라는 정수를 사용해서 기억한다.
					이때 사용되는 97 이라는 숫자는 askii 코드값이다.
				
				'\u0000' = 실제 유니코드 값으로 문자를 기억시킬 수 있다.
					0000 은 원하는 문자에 해당하는 Uni Code 값
					
			5) 문자열 형 - " " (클래스 타입)
				한 글자 이상으로 구성된 문자를 의미한다.
				==> 엄밀히 말하면 기본 상수는 아니다.
					개발자 입장에서 매우 빈번하게 사용하는 형태이므로 
					포함시켜놓았다. 
			
---------------------------------------------------------------------------------------------

2. 변수
	참고)
		변수의 필요성
			개발자가 입력한 데이터는 일단 리터럴 풀에 저장된다.
			그리고 프로그램이 리터럴 풀에 있는 데이터를 꺼내서 사용하게 된다.
			
			리터럴 풀은 
			주소를 모르면 사용할 수 없다.
			(반드시 주소를 알아야 사용할 수 있다.)
			
			변수는 리터럴 풀에 저장된 데이터를 개발자가 필요한 순간에 재사용할 수 있도록
			저장된 주소를 기억해 놓는 역할을 한다.
			
	참고) 
		Stack 의 특징
			1. 메모리의 별칭을 붙여서 사용할 수 있는 영역이다.
				(별칭은 개발자가 붙이는 것이므로
					개발자가 가장 손쉽게 사용할 수 있는 영역이다.)
			
			2. 8개의 영역 중에서 리터럴 풀 다음으로 가장 작은 영역을 운영체재에게서 배정받는다.
				(따라서 Stack 에는 많은 양의 데이터를 보관하려 한다면 문제가 생길 수 있다.)
			
------------------------------------------------------------------------------------------------

	리터럴 풀에 있는 데이터를 Stack 에서 기억하는 방법
		
		1. Stack 에 필요한 메모리를 할당 받는다.
			
			형식)
				데이터타입		변수 이름;

				==> 데이터타입의 기술은 2가지 의미를 담고 있다.
						1. 기억할 데이터의 형태
						2. 필요한 메모리의 크기
				
				참고)
					변수 이름은 앞에서 설명한 Stack 에 붙이는 별칭이다.
					따라서 변수 이름만 기억하고 있으면 언제든지
					이 변수가 기억하고 있는 데이터를 사용할 수 있게 된다.
				
				참고)
					데이터 타입에 의한 변수의 분류
				
						1) 기본형 변수
							- 자바에서 제공해주는 기본 데이터 타입의 데이터를 기억할 변수
								
								참고)
									자바의 기본 데이터 타입
							참고)
								Stack 영역에 메모리를 할당받는 방법
									JVM 에게 할당받은 메모리 크기와 그 안에 저장할 데이터 형태를 알려줘야 한다.
						
									종류											
										논리형 
											boolean 	- 1byte
										
										문자형
											char 		- 2byte
											
										정수형
											long 		- 8byte
											short 		- 2byte
											*int 		- 4byte
											byte 		- 1byte
											
										실수형
											*double		- 8byte
											float		- 4byte
											
											*: 숫자형 기본 입력 타입
												
						2) 참조형 변수
							- 기본형 데이터 이외의 모든 데이터를 기억하는 변수
								(클래스를 기억하는 변수, 클래스로 만들어진 변수, 클래스타입 변수)
						
					
		2. 대입(기억) 연산자를 이용해서 필요한 데이터를 기억한다.
		
			형식)
				변수 이름 = 데이터;
			ex)
				no = 10;
			
	상수
		•	알려져 있는 양이나 정보에 대한 상징적인 이름
		•	한 번 정하면 수정할 수 없다.
		•	상수명은 대문자로 한다.
		•	상수는 선언과 동시에 초기화 해야한다.(값을변경할수없으므로...)
	
	형식
		•	final 데이터타입 상수명(대문자) = 데이터; ==> 상수 선언 & 초기화
	
		int -2^31 ~ 2^31 -1 ==> 0을 포함하기 때문에
			만약 int 에서 2^31 보다 1 큰수가 나온다면 2^31 + 1 값이 아닌 -2^31이 되므로 주의해야 한다.


--------------------------------------------------------------------------------------------------------

	형변환
		값의 자료형을 원하는 자료형으로 변환하는 작업
			1. 리터럴 형변환
				입력할 때 따로 형태를 정해주지 않으면 리터럴 영역에 저장된다.
				이때 테이터의 타입이 자동으로 결정되고 크기도 정해진다. 이것을 리터럴타입이라 한다.
				정수는 int 로 자동 결정되고 실수는 double 타입으로 자동으로 결정이 된다.
				이때 메모리의 크기를 정해줄 수도 있는데 이때 쓰는 방법이 리터럴 형변환 이다.
				
				long 타입 => 	데이터l;
				float 타입 =>	데이터f;
				
			2. 자동 형변환
				지정하지 않아도 자동적으로 형태를 바꿔서 사용되는 경우
 				: 작은 형태의 데이터가 큰 형태의 데이터로 필요한 경우 자동 형변환이 일어난다.
			
			3. 강제 형변환
				자동 형변환이 불가능한 경우 개발자가 강제로 형 변환을 할 필요가 있다
				float num = 10.; 은 안됨
				(float) 10.0; 은 됨


=============================================================================================================

자바 프로그램의 토큰 구분
==> 컴파일러는 토큰단위로 번역을 시도한다.
	따라서 개발자는 컴파일러가 번역하는 토큰을 구분해 줘야 한다.
	이것이 " ; " 이라는 기호를 이용해서 구분하게 된다.
	
	우리가 습관적으로
		int no = 10;
	했던 의미는 토큰을 구분하기 위한 기호였다.	
	
	결과적으로 토큰은 하나의 명령이 종료되었음을 알려주는 기호가 된다.
	
	만약, 개발자가 토큰 구분을 하지 않으면 오류가 발생할 수 있다.
	
	ex)
		int no1 = 10
		int no2 = 20;
			==> 컴파일러는 두 줄을 하나의 명령으로 인식해서 처리하게 될 것이고
				이런 명령 형식은 존재하지 않으므로 오류가 발생한다.	
					
	ex)
		int no1 = 10; int no2 = 10;
			==> 비록 한 줄로 입력했지만, 두 개의 명령이 인식해서 먼저 no1을 처리하고
				그 명령이 처리된 후 no2 에 대한 명령을 처리하게 된다.
				
	참고)
		; 대신 } 기호가 그 역할을 대신할 수 있다.
		
		ex)
			if(조건식){
				(조건식이 true면)실행문...
			} // 이 부분에서 토큰이 발생하게 된다.
			
			
					
					
					
					
					
					
					
					
					
					
					
					
					
						
			
			
	
---------------------------------------------------------------------------------------

사람이 이해하는 언어

_________________________

기계가 이해하는 언어